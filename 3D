from PIL import Image
import matplotlib.pyplot as plt
from math import sin, cos, pi

class Point:
    def __init__(self, x: float, y: float, z: float):
        self.x = x
        self.y = y
        self.z = z

class Drawing3DModel:
    def __init__(self, file_path: str):
        self.dots = []
        self.figures = []
        with open(file_path) as file:
            info = file.read().split('\n')
            for line in info:
                if line.startswith("v"):
                    _, *line = line.split()
                    line = list(map(float, line))
                    point = Point(line[0], line[1], line[2])
                    self.dots.append(point)
                elif line.startswith("f"):
                    _, *line = line.split()
                    self.figures.append(list(map(int, line)))

    def bresenham(self, image, x0: int, y0: int, x1: int, y1: int, color: tuple = (255, 255, 255)):
        # Реализация алгоритма Bresenham для отрисовки отрезка на изображении
        # ...

    def transform_point(self, matrix: list, vector: list) -> Point:
        new_vector = [0] * len(vector)
        for i in range(len(matrix)):
            for j in range(len(vector)):
                new_vector[i] += matrix[i][j] * vector[j]
        return Point(new_vector[0], new_vector[1], new_vector[2])

    def move(self, dx: float, dy: float, dz: float) -> list:
        return [
            [1, 0, 0, dx],
            [0, 1, 0, dy],
            [0, 0, 1, dz],
            [0, 0, 0, 1]
        ]

    def scale(self, kx: float, ky: float, kz: float) -> list:
        return [
            [kx, 0, 0, 0],
            [0, ky, 0, 0],
            [0, 0, kz, 0],
            [0, 0, 0, 1]
        ]

    def rotate_X(self, angle: float, is_radian: bool = False) -> list:
        if not is_radian:
            angle = self.to_radians(angle)

        return [
            [1, 0, 0, 0],
            [0, cos(angle), -sin(angle), 0],
            [0, sin(angle), cos(angle), 0],
            [0, 0, 0, 1]
        ]

    def rotate_Y(self, angle: float, is_radian: bool = False) -> list:
        if not is_radian:
            angle = self.to_radians(angle)

        return [
            [cos(angle), 0, sin(angle), 0],
            [0, 1, 0, 0],
            [-sin(angle), 0, cos(angle), 0],
            [0, 0, 0, 1]
        ]

    def rotate_Z(self, angle: float, is_radian: bool = False) -> list:
        if not is_radian:
            angle = self.to_radians(angle)

        return [
            [cos(angle), -sin(angle), 0, 0],
            [sin(angle), cos(angle), 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
        ]

    def to_radians(self, angle: float) -> float:
        return angle * (pi / 180)

    def draw_3d_model(self):
        with Image.new("RGB", (100, 100)) as image:
            for i in range(len(self.dots)):
                self.dots[i] = self.transform_point(self.scale(50, 50, 50), [self.dots[i].x, self.dots[i].y, self.dots[i].z])
                self.dots[i] = self.transform_point(self.rotate_Z(25), [self.dots[i].x, self.dots[i].y, self.dots[i].z])
                self.dots[i] = self.transform_point(self.rotate_Y(55), [self.dots[i].x, self.dots[i].y, self.dots[i].z])
                self.dots[i] = self.transform_point(self.move(50, 50, 0), [self.dots[i].x, self.dots[i].y, self.dots[i].z])

            for figure in self.figures:
                for i in range(len(figure)):
                    self.bresenham(image,
                                   int(self.dots[figure[i] - 1].x),
                                   int(self.dots[figure[i] - 1].y),
                                   int(self.dots[figure[(i + 1) % len(figure)] - 1].x),
                                   int(self.dots[figure[(i + 1) % len(figure)] - 1].y))

            plt.imshow(image)
            plt.show()
